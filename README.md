# VM & Interpreter in C

A bytecode virtual machine and interpreter for the own programming language, written in C. This implementation is largely based on the Part III of the book **Crafting Interpreters** by Robert Nystrom.

**Project status:** Work in progress: scanner, compiler, debugger and VM are implemented and can execute programs that include `for` and `while` loop, `if/else` statements, Local and Global Scope, 'print' statement.

---

## Table of Contents
- [Features](#features)
- [Repository Structure](#repository-structure)
- [Prerequisites](#prerequisites)
- [Build](#build)
- [Usage](#usage)
- [Development notes](#development-notes)

---

## Features
- Scanning: tokenizes source code into tokens
- Compiling: Pratt parser and bytecode generator
- Virtual Machine: stack-based VM that executes compiled chunks
- REPL: interactive Read-Eval-Print Loop with line editing/history
- Basic arithmetic and expressions
- Control flow: if/else statements (conditional execution)
- Variables: local and global variables with lexical scoping and assignment
- Functions (as implemented in the repo)

---

## Changelog
- 07-01-2026 — **Added support for `if/else` statements** in the compiler and VM.
- 08-01-2026 — **Added support for `while` statements** in the compiler.
- 10-01-2026 — **Implemented `for` loop statement**
- 11-01-2026 — **Created a file name `test.as` for some sample codes that lang supports so far**
- 12-01-2026 **Updated `object.h` for supporting fn calling**

## Repository Structure
Key files and directories (top-level):

- `main.c` — program entry & CLI
- `scanner.c`, `scanner.h` — tokenizer for source
- `compiler.c`, `compiler.h` — parser + bytecode compiler
- `vm.c`, `vm.h` — virtual machine executing bytecode
- `object.c`, `object.h` — runtime objects and value handling
- `memory.c`, `memory.h` — memory management helpers
- `debug.c`, `debug.h` — disassembly and debugging helpers
- `chunk.c`, `chunk.h` — bytecode chunk representation
- `table.c`, `table.h` — hash table implementation for globals
- `value.c`, `value.h` — value representation and utilities
- `Makefile` — build targets
- `build/` — build artifacts (generated)

> Tip: See inline comments in the `.c/.h` files for details about implementation and interfaces.

## Prerequisites
- A C compiler (gcc/clang)
- make
- Readline development library (for REPL history/editing)

On Debian/Ubuntu/WSL:

```bash
sudo apt update
sudo apt install build-essential libreadline-dev
```

On macOS (with Homebrew):

```bash
brew install readline
# you may need to set CPPFLAGS/LDFLAGS so the compiler finds readline headers and libs
```

---

## Build
From the project root run:

```bash
make
```

This builds the `asharp` executable (or similar binary in the project root). To do a clean rebuild:

```bash
make clean && make
```

---

## Usage
Run the REPL:

```bash
./asharp
```

Execute a source file (supports `.as` extensions):

```bash
./asharp path/to/script.as
```

Example snippets to try in the REPL:

```
print 1 + 2 * (3 - 4);
```

An example with current capabilities of A-Sharp:

```
var i = 0;
while (i < 5) {
  print i;
  i = i + 1;
}

//Global Scope
var a = "Programming with ";
var b = "A-Sharp";
{
  //Local Scope
  var a = 15;
  var b = 15;
  print a+b;
}
print a + b;

a = 8;

if (a > 10){
  print "Hello";
}
else {
  print "World!";
}
```
An example of a Fibonacci generator:
```
// A Fibonacci generator using a for loop!
var a = 0;
var b = 1;
for (var i = 0; i < 5; i = i + 1) {
  print a;
  var temp = a + b;
  a = b;
  b = temp;
}
```

Note: the interpreter reads files with the `.as` extension; try `./asharp test.as`.

---

## Development notes
- The compiler emits bytecode into `Chunk` structures (`chunk.c/h`) which the VM (`vm.c/h`) then executes.
- `debug.c` contains a `disassemble` helper useful to inspect generated bytecode during development.
- Follow the structure from *Crafting Interpreters* if you plan to add language features — the code is organized by the same components (scanner → parser/compiler → VM).
